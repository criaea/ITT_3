<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Millennium Profile</title>
    <!-- Loading Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Loading D3.js for the chart --><script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* D3 Chart text styling */
        .chart-label-title {
            font-size: 1.5rem; /* Tailwind text-2xl equivalent */
            font-weight: 700; /* Tailwind font-bold equivalent */
            fill: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-anchor: middle; /* Center text horizontally */
        }
        .chart-label-score {
            font-size: 1.25rem; /* Tailwind text-xl equivalent */
            font-weight: 500; /* Tailwind font-medium equivalent */
            fill: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-anchor: middle; /* Center text horizontally */
        }
        /* D3 Radar Chart text styling */
        .radar-label {
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            text-anchor: middle;
            fill: #374151; /* gray-700 */
        }
        
        /* --- REMOVED Word Map Text Styles --- */


        /* --- New Drag and Drop Styles --- */
        /* The draggable word itself */
        .draggable-word {
            padding: 0.75rem;
            background-color: white;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            cursor: grab;
            transition: all 0.2s ease;
            text-align: center;
            font-weight: 500;
        }
        
        .draggable-word:active {
            cursor: grabbing;
        }

        /* Style for the item being dragged */
        .dragging {
            opacity: 0.5;
            background: #f0f9ff; /* light-blue-50 */
            border: 1px dashed #0284c7; /* blue-600 */
        }

        /* The empty spot to drop into */
        .drop-spot {
            padding: 1rem;
            border: 2px dashed #9ca3af; /* gray-400 */
            border-radius: 0.5rem; /* rounded-lg */
            min-height: 80px; /* Give it a minimum height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            background-color: #f9fafb; /* gray-50 */
        }
        
        .drop-spot-label {
            font-weight: 600;
            color: #4b5563; /* gray-600 */
        }
        
        .drop-spot-subtext {
            font-size: 0.875rem;
            color: #6b7280; /* gray-500 */
        }

        /* When dragging OVER a spot */
        .drop-spot.highlight,
        .word-bank-dropzone.highlight {
            background-color: #dbeafe; /* blue-100 */
            border-color: #3b82f6; /* blue-500 */
        }

        /* When a spot is FILLED */
        .drop-spot-filled {
            border-style: solid;
            border-color: #10b981; /* green-500 */
            background-color: #ecfdf5; /* green-50 */
            padding: 0.5rem; /* Reduce padding when filled */
        }

        .drop-spot-filled .drop-spot-label,
        .drop-spot-filled .drop-spot-subtext {
            display: none; /* Hide placeholder text */
        }
        
        /* The word bank on the right */
        .word-bank-dropzone {
            padding: 1rem;
            background-color: #f3f4f6; /* gray-100 */
            border: 2px solid #e5e7eb; /* gray-200 */
            border-radius: 0.5rem;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* space-y-3 */
        }

        /* --- NEW: Style for Key Words list --- */
        .key-word-rank-1 { font-weight: 700; color: #1f2937; } /* bold, gray-800 */
        .key-word-rank-2 { font-weight: 500; color: #374151; } /* medium, gray-700 */
        .key-word-rank-3 { font-weight: 400; color: #4b5563; opacity: 0.9; } /* normal, gray-600 */
        .key-word-rank-4 { font-weight: 300; color: #6b7280; opacity: 0.8; } /* light, gray-500 */
        /* --- END NEW --- */

    </style>
</head>
<body class="bg-gray-100 font-sans p-4 md:p-8 min-h-screen flex items-center justify-center">

    <!-- Main Test Page Container --><main id="test-page" class="container bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-4xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-3 text-blue-700">
            Millennium Profile 
            <span class="text-sm font-normal text-gray-500 align-middle ml-2">draft version</span>
        </h1>
        <p class="text-center text-gray-600 mb-8">
            For each question, drag the words from the "Word Choices" into the slots on the right.
        </p>

        <!-- New Question Counter -->
        <p id="question-counter" class="text-center text-lg font-semibold text-gray-700 mb-4"></p>

        <!-- Questions Container --><div id="questions-container" class="space-y-6">
            <!-- All 24 questions will be rendered here by JS, but hidden -->
        </div>

        <!-- Navigation/Action Buttons -->
        <div class="mt-10 flex flex-col items-center justify-center gap-4">
            
            <!-- Developer Fill Button -->
            <button id="dev-fill-button" 
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-full sm:w-auto">
                Developer: Random Fill
            </button>
            
            <!-- Navigation buttons -->
            <div class="flex flex-row justify-center gap-4 w-full sm:w-auto">
                <button id="prev-button" 
                        class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-1/2 sm:w-auto">
                    Previous
                </button>
                <button id="next-button" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-1/2 sm:w-auto"
                        disabled>
                    Next
                </button>
            </div>
            
            <!-- Save Button (hidden initially) -->
            <button id="save-button" 
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto"
                    disabled style="display: none;">
                Show Results
            </button>
        </div>
        <p id="error-message" class="text-red-600 font-semibold mt-4 h-6 text-center"></p>
        <p id="success-message" class="text-green-600 font-semibold mt-4 h-6 text-center"></p>
    
        <!-- NEW FOOTER -->
        <p class="text-center text-sm text-gray-500 mt-8">&copy; ourfields.ie</p>
    </main>

    <!-- Results Page Container (hidden by default) 
    --><div id="results-page" class="hidden fixed inset-0 bg-gray-100 p-4 overflow-y-auto">
        <div class="container bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-7xl mx-auto flex flex-col items-center my-auto"> <!-- CHANGED: max-w-5xl to max-w-7xl -->
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-blue-700">
                Your Profile Results
                <span class="text-sm font-normal text-gray-500 align-middle ml-2">draft version</span>
            </h1>
            
            <!-- Grid container for multiple charts -->
            <div class="grid grid-cols-1 md:grid-cols-1 gap-8 w-full">

                <!-- 1. Chart 1.5: Quadrant Chart (Rectangle Avg) - FIRST CHART -->
                <div class="w-full"> 
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Quadrant Chart (Rectangle Average)</h2>
                    <div id="quadrant-chart-rect-container" class="w-full h-[70vh] overflow-hidden"> 
                        <svg id="quadrant-chart-rect" class="w-full h-full"></svg>
                    </div>
                    <!-- ARROW KEY/LEGEND ADDED HERE -->
                    <div class="mt-4 flex flex-col items-center space-y-2 text-lg font-semibold">
                        <p class="text-gray-700">Adjustment Visual (Appears if score is more than 24 points from the 120 average):</p>
                        <div class="flex justify-center space-x-6">
                            <div class="flex items-center space-x-2 text-blue-700">
                                <span class="font-bold">Line towards center:</span> Score **> 144** (Must shrink to reach 120).
                            </div>
                            <div class="flex items-center space-x-2 text-green-700">
                                <span class="font-bold">Line away from center:</span> Score **< 96** (Must grow to reach 120).
                            </div>
                        </div>
                    </div>
                </div>

                
                <!-- 2. Chart 4: Pie Chart (Proportions) - SECOND CHART (MOVED UP) -->
                <div class="w-full"> 
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Pie Chart (Proportions)</h2>
                    <div id="pie-chart-container" class="w-full h-[60vh] overflow-hidden"> 
                        <svg id="pie-chart" class="w-full h-full"></svg>
                    </div>
                </div>

                <!-- 3. Chart 1.6: Quadrant Chart (Words) - THIRD CHART (MOVED DOWN) -->
                <div class="w-full">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Quadrant Chart (Key Words)</h2>
                    <div id="quadrant-chart-words-container" class="w-full h-[95vh] overflow-hidden"> 
                        <svg id="quadrant-chart-words" class="w-full h-full"></svg>
                    </div>
                    <!-- ARROW KEY/LEGEND REMOVED FROM HERE -->
                </div>

            </div>

            <!-- Profile Analysis Section -->
            <div class="w-full mt-12">
                <h2 class="text-3xl font-bold text-center text-gray-800 mb-6">Your Profile Analysis</h2>
                <!-- This is now a single container with a 2x2 grid inside -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-px bg-gray-300 rounded-lg shadow-md overflow-hidden">
                    
                    <!-- BLUE (Upper Left) -->
                    <div class="bg-blue-100 p-6"> <!-- Fixed typo classV and removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-blue-800 mb-3">BLUE (Upper Left)</h3>
                        <ul class="list-disc list-inside text-blue-900 space-y-1">
                            <li>Wants to see data and statistics on performance.</li>
                            <li>Looks at energy efficiency.</li>
                            <li>Looks at cost of vehicle, trade in value.</li>
                            <li>Comparison shopping with other vehicles.</li>
                            <li>Ease of maintenance.</li>
                            <li>Wants to know how it works.</li>
                            <li>Likes power and precision handling.</li>
                        </ul>
                    </div>

                    <!-- RED (Upper Right) -->
                    <div class="bg-red-100 p-6"> <!-- Removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-red-800 mb-3">RED (Upper Right)</h3>
                        <ul class="list-disc list-inside text-red-900 space-y-1">
                            <li>Looks at the aesthetic qualities: sportiness, colour, form. "Cutting Edge" qualities.</li>
                            <li>Wants it to fit the dream, personal image, long range plans.</li>
                            <li>More willing to experiment and take some risks.</li>
                            <li>1st model buyer, early innovator.</li>
                        </ul>
                    </div>

                    <!-- GREEN (Lower Left) -->
                    <div class="bg-green-100 p-6"> <!-- Removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-green-800 mb-3">GREEN (Lower Left)</h3>
                        <ul class="list-disc list-inside text-green-900 space-y-1">
                            <li>Interested in safety features, and durability.</li>
                            <li>The practicality of size, number of doors, storage space, strain resistant materials, features such as interior trunk/gas lock.</li>
                            <li>Looks at maintenance requirements.</li>
                            <li>Have done research and know what they want.</li>
                        </ul>
                    </div>

                    <!-- YELLOW (Lower Right) -->
                    <div class="bg-yellow-100 p-6"> <!-- Removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-yellow-800 mb-3">YELLOW (Lower Right)</h3>
                        <ul class="list-disc list-inside text-yellow-900 space-y-1">
                            <li>The 'Feel' and comfort of the vehicle is important, user friendliness of controls.</li>
                            <li>WWants to 'Love' the car.</li>
                            <li>Impacted by friendliness of sale and service organisation.</li>
                            <li>Knows it's a right choice.</li>
                            <li>Will buy based on a friends recommendations.</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="text-center mt-12"> <!-- Added more margin-top -->
                <button id="back-to-test-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300">
                    Back to Test
                </button>
            </div>
            <!-- NEW FOOTER -->
            <p class="text-center text-sm text-gray-500 mt-8">&copy; ourfields.ie</p>
        </div>
    </div>


    <script>
        // --- PAGE ELEMENTS ---
        const testPage = document.getElementById('test-page');
        const resultsPage = document.getElementById('results-page');
        const questionsContainer = document.getElementById('questions-container');
        const saveButton = document.getElementById('save-button');
        const successMessage = document.getElementById('success-message');
        const errorMessage = document.getElementById('error-message');
        const backToTestButton = document.getElementById('back-to-test-button');
        const devFillButton = document.getElementById('dev-fill-button');
        
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const questionCounter = document.getElementById('question-counter');

        // --- STATE ---
        let currentQuestionIndex = 0;
        const totalQuestions = 24;
        let draggedItem = null;

        // --- QUESTION DATA ---
        const questionsData = [
            // Q1
            [
                { word: "Gentle, Kindly", color: "green" },
                { word: "Persuasive, Convincing", color: "yellow" },
                { word: "Humble, reserved", color: "blue" },
                { word: "Original, inventive", color: "red" }
            ],
            // Q2
            [
                { word: "Attractive, charming", color: "yellow" },
                { word: "Cooperative, agreeable", color: "blue" },
                { word: "Stubborn, unyielding", color: "red" },
                { word: "Pleasing, Pleasant", color: "green" }
            ],
            // Q3
            [
                { word: "Easily lead, follower", color: "blue" },
                { word: "Bold, daring", color: "red" },
                { word: "Loyal, faithful", color: "green" },
                { word: "Charming, delightful", color: "yellow" }
            ],
            // Q4
            [
                { word: "Open-minded, receptive", color: "blue" },
                { word: "Obliging, helpful", color: "green" },
                { word: "Will power, strong willed", color: "red" },
                { word: "Cheerful, joyful", color: "yellow" }
            ],
            // Q5
            [
                { word: "Jovial, jolting", color: "yellow" },
                { word: "Precise, exact", color: "blue" },
                { word: "Gutsy, brazen", color: "red" },
                { word: "Even tempered, calm", color: "green" }
            ],
            // Q6
            [
                { word: "Competitive, seeking to win", color: "red" },
                { word: "Considerate, caring, thoughtful", color: "green" },
                { word: "Outgoing, fun loving", color: "yellow" },
                { word: "Harmonious, agreeable", color: "blue" }
            ],
            // Q7
            [
                { word: "Fussy, hard to please", color: "blue" },
                { word: "Obedient, dutiful", color: "green" },
                { word: "Unconquerable, determined", color: "red" },
                { word: "Playful, full of fun", color: "yellow" }
            ],
            // Q8
            [
                { word: "Brave, courageous", color: "red" },
                { word: "Inspiring, motivating", color: "yellow" },
                { word: "Submissive, yielding", color: "green" },
                { word: "Timid, shy quiet", color: "blue" }
            ],
            // Q9
            [
                { word: "Sociable", color: "yellow" },
                { word: "Patient", color: "green" }, // <-- FIX 1 HERE
                { word: "Self reliant, independent", color: "red" },
                { word: "Mild, reserved", color: "blue" }
            ],
            // Q10
            [
                { word: "Adventurous", color: "red" },
                { word: "Receptive, open to suggestions", color: "green" },
                { word: "Warm, friendly", color: "yellow" },
                { word: "Moderate", color: "blue" }
            ],
            // Q11
            [
                { word: "Talkative, chatty", color: "yellow" },
                { word: "Controlled, restrained", color: "green" },
                { word: "Conventional", color: "blue" },
                { word: "Decisive, certain", color: "red" }
            ],
            // Q12
            [
                { word: "Polished, smooth talker", color: "yellow" },
                { word: "Daring, risk-taker", color: "red" },
                { word: "Diplomatic, tactful", color: "blue" },
                { word: "Satisfied, content", color: "green" }
            ],
            // Q13
            [
                { word: "Aggressive, challenger", color: "red" },
                { word: "Outgoing, entertaining", color: "yellow" },
                { word: "Easily taken advantage of", color: "green" },
                { word: "Fearful, afraid", color: "blue" }
            ],
            // Q14
            [
                { word: "Cautious, wary", color: "blue" },
                { word: "Determined, decided", color: "red" },
                { word: "Convincing, assuring", color: "yellow" },
                { word: "Good-natured, pleasant", color: "green" }
            ],
            // Q15
            [
                { word: "Willing, compliant", color: "green" },
                { word: "Eager, anxious", color: "yellow" },
                { word: "Agreeable, Consenting", color: "blue" },
                { word: "High-spirited, lively, enthusiastic", color: "red" }
            ],
            // Q16
            [
                { word: "Confident, assured", color: "yellow" },
                { word: "Sympathetic, compassionate", color: "green" },
                { word: "Tolerant", color: "blue" },
                { word: "Assertive, aggressive", color: "red" }
            ],
            // Q17
            [
                { word: "Well disciplined, self-controlled", color: "blue" },
                { word: "Generous, willing to share", color: "green" },
                { word: "Animated, uses gestures for expression", color: "yellow" },
                { word: "Persistent, unrelenting", color: "red" }
            ],
            // Q18
            [
                { word: "Brave, courageous", color: "red" },
                { word: "Inspiring, motivating", color: "yellow" },
                { word: "Submissive, yielding", color: "blue" },
                { word: "Timid, shy quiet", color: "green" }
            ],
            // Q19
            [
                { word: "Respectful", color: "blue" },
                { word: "Pioneering, exploring", color: "red" },
                { word: "Optimistic, positive", color: "yellow" },
                { word: "Accommodating, willing to please", color: "green" }
            ],
            // Q20
            [
                { word: "Argumentative, Controlling", color: "red" },
                { word: "Adaptable, flexible", color: "green" },
                { word: "Nonchalant, indifferent", color: "blue" }, // <-- FIX 2 HERE
                { word: "Light-hearted, carefree", color: "yellow" }
            ],
            // Q21
            [
                { word: "Trusting, faith in others", color: "yellow" },
                { word: "Contented, satisfied", color: "green" },
                { word: "Positive, sure", color: "red" },
                { word: "Peaceful, tranquil", color: "blue" }
            ],
            // Q22
            [
                { word: "Good mixer, sociable", color: "yellow" },
                { word: "Educated, Knowledgeable", color: "blue" },
                { word: "Vigorous, energetic", color: "red" },
                { word: "Lenient", color: "green" }
            ],
            // Q23
            [
                { word: "Companionable", color: "yellow" },
                { word: "Accurate, correct", color: "blue" },
                { word: "Outspoken, speaks freely", color: "red" },
                { word: "Restrained, reserved, controlled", color: "green" }
            ],
            // Q24
            [
                { word: "Restless, unable to rest or relax", color: "red" },
                { word: "Neighborly, friendly", color: "green" },
                { word: "Popular, liked by many", color: "yellow" },
                { word: "Neat, organized", color: "blue" }
            ]
        ];

        // --- QUESTION CARD FUNCTIONS ---

        function createDraggableWord(word, color) {
            const wordDiv = document.createElement('div');
            wordDiv.className = 'draggable-word';
            wordDiv.draggable = true;
            wordDiv.textContent = word;
            wordDiv.dataset.color = color;
            return wordDiv;
        }

        function createQuestionCard(questionWords, index) {
            const card = document.createElement('div');
            card.className = 'question-card bg-white border border-gray-200 rounded-lg p-5 shadow-sm';
            card.dataset.questionId = index;
            card.dataset.status = 'invalid'; // Invalid by default
            
            if (index !== 0) {
                card.style.display = 'none';
            }
            
            // Create word bank items
            const wordBankWords = questionWords.map(item => createDraggableWord(item.word, item.color).outerHTML).join('');

            card.innerHTML = `
                <h2 class="text-xl font-semibold text-gray-900 mb-2">Question ${index + 1}</h2>
                <p class="text-gray-600 mb-4 text-sm">Drag the words from the "Word Choices" (left) into "Your Order" slots (right).</p>
                <div class="flex flex-col md:flex-row gap-6">
                    
                    <!-- Left Column: Word Bank -->
                    <div class="flex-1">
                         <h3 class="font-semibold text-gray-700">Word Choices:</h3>
                         <div class="word-bank-dropzone mt-2">
                            ${wordBankWords}
                         </div>
                    </div>
                    
                    <!-- Right Column: Rank Spots -->
                    <div class="flex-1 space-y-3">
                        <h3 class="font-semibold text-gray-700">Your Order:</h3>
                        <div class="drop-spot" data-rank="1">
                            <span class="drop-spot-label">1st Place</span>
                            <span class="drop-spot-subtext">(Most like you)</span>
                        </div>
                        <div class="drop-spot" data-rank="2">
                            <span class="drop-spot-label">2nd Place</span>
                        </div>
                        <div class="drop-spot" data-rank="3">
                            <span class="drop-spot-label">3rd Place</span>
                        </div>
                        <div class="drop-spot" data-rank="4">
                            <span class="drop-spot-label">4th Place</span>
                            <span class="drop-spot-subtext">(Least like you)</span>
                        </div>
                    </div>
                    
                </div>
                <div class="error-message text-red-600 text-sm font-medium mt-3 h-5"></div>
            `;
            return card;
        }

        // --- NAVIGATION FUNCTION ---

        function showQuestion(index) {
            const allCards = document.querySelectorAll('.question-card');
            allCards.forEach(card => {
                card.style.display = 'none';
            });
            if (allCards[index]) {
                allCards[index].style.display = 'block';
            }
            questionCounter.textContent = `Question ${index + 1} of ${totalQuestions}`;
            prevButton.disabled = (index === 0);
            
            if (index === totalQuestions - 1) {
                nextButton.style.display = 'none';
                saveButton.style.display = 'inline-flex';
                // Final check for all cards before enabling save
                checkFormCompletion(true);
            } else {
                nextButton.style.display = 'inline-flex';
                saveButton.style.display = 'none';
                // Check current card to enable next
                checkFormCompletion(false);
            }
        }

        // --- VALIDATION FUNCTIONS ---

        function validateCard(card) {
            const bank = card.querySelector('.word-bank-dropzone');
            const wordsLeft = bank.querySelectorAll('.draggable-word').length;
            const errorMessage = card.querySelector('.error-message');
            
            if (wordsLeft === 0) {
                card.dataset.status = 'valid';
                if (errorMessage) errorMessage.textContent = '';
                return true;
            } else {
                card.dataset.status = 'invalid';
                if (errorMessage) errorMessage.textContent = `You still need to assign ${wordsLeft} words.`;
                return false;
            }
        }

        function checkFormCompletion(checkAll = false) {
            const allCards = document.querySelectorAll('.question-card');
            if (checkAll) {
                // Check all cards for the final save button
                let allValid = true;
                allCards.forEach(card => {
                    if (card.dataset.status !== 'valid') {
                        allValid = false;
                    }
                });
                saveButton.disabled = !allValid;
            } else {
                // Check only the current card for the 'next' button
                const currentCard = allCards[currentQuestionIndex];
                if (currentCard) {
                    nextButton.disabled = (currentCard.dataset.status === 'invalid');
                }
            }
        }

        // --- CALCULATION & CHARTING FUNCTIONS ---

        // NEW: Collects scores AND ranked word list
        function collectRankedWords() {
            const pointMap = { "1": 10, "2": 6, "3": 3, "4": 1 };
            let scores = { blue: 0, red: 0, green: 0, yellow: 0 };
            // This will hold all words, sorted by color
            let rankedWords = { 
                blue: [], 
                red: [], 
                green: [], 
                yellow: [] 
            };
            
            const allCards = document.querySelectorAll('.question-card');
            
            allCards.forEach(card => {
                const spots = card.querySelectorAll('.drop-spot');
                spots.forEach(spot => {
                    const rank = spot.dataset.rank; // "1", "2", "3", "4"
                    const word = spot.querySelector('.draggable-word');
                    if (word) {
                        const color = word.dataset.color;
                        const points = pointMap[rank];
                        if (color && points != null) {
                            // 1. Add to total score
                            scores[color] += points;
                            // 2. Add to ranked word list
                            rankedWords[color].push({
                                text: word.textContent,
                                rank: rank
                            });
                        }
                    }
                });
            });
            
            // Sort each color's word list by rank
            for (const color in rankedWords) {
                rankedWords[color].sort((a, b) => a.rank - b.rank);
            }
            
            return { scores, rankedWords };
        }

        // DEPRECATED: calculateScores() is now part of collectRankedWords()
        function calculateScores() {
            // This function is no longer called, but we leave it
            // just in case.
            const data = collectRankedWords();
            return data.scores;
        }

        // --- REMOVED: CHART 0: WORD MAP CHART ---
        
        // --- NEW: Function to populate Key Words (Not used in new design, but kept for logic) ---
        function populateWordAnalysis(scores, rankedWords) { // <-- Now receives scores
            const colors = ['blue', 'red', 'green', 'yellow'];
            let capacities = {};
            let wordsToDisplay = {};

            // 1. Calculate capacity and get words for all colors FIRST
            colors.forEach(color => {
                const wordCapacity = Math.floor(scores[color] / 20);
                capacities[color] = wordCapacity;
                wordsToDisplay[color] = rankedWords[color].slice(0, wordCapacity);
            });

            // 2. Calculate grid proportions
            const totalWords = capacities.blue + capacities.red + capacities.green + capacities.yellow;

            let topRowFr, bottomRowFr, leftColFr, rightColFr;

            if (totalWords === 0) {
                // Default to equal grid if no words
                topRowFr = 1; bottomRowFr = 1; leftColFr = 1; rightColFr = 1;
            } else {
                const topRowWords = capacities.blue + capacities.red;
                const bottomRowWords = capacities.green + capacities.yellow;
                const leftColWords = capacities.blue + capacities.green;
                const rightColWords = capacities.red + capacities.yellow;

                // Use 1 as a minimum to prevent 0fr
                topRowFr = topRowWords || 1;
                bottomRowFr = bottomRowWords || 1;
                leftColFr = leftColWords || 1;
                rightColFr = rightColWords || 1;
            }

            // 3. Apply proportions to the grid container
            const gridContainer = document.getElementById('key-words-grid');
            if (gridContainer) {
                gridContainer.style.gridTemplateRows = `${topRowFr}fr ${bottomRowFr}fr`;
                gridContainer.style.gridTemplateColumns = `${leftColFr}fr ${rightColFr}fr`;
            }

            // 4. Now, populate the HTML for each box
            colors.forEach(color => {
                const container = document.getElementById(`${color}-key-words`);
                if (!container) return;

                const currentWords = wordsToDisplay[color]; // This is an array

                if (currentWords.length === 0) {
                     if (scores[color] > 0) {
                        container.innerHTML = `<p class="text-sm italic text-gray-600">No words to display at this point level.</p>`;
                    } else {
                        container.innerHTML = `<p class="text-sm italic text-gray-600">No score for this color.</p>`;
                    }
                    return;
                }

                // 5. Create the simple bulleted list
                // --- FIX: Change wordsToDisplay.map to currentWords.map ---
                const listHtml = currentWords.map(word => {
                    // Add a style based on rank
                    return `<li class="key-word-rank-${word.rank}">${word.text}</li>`;
                }).join('');
                
                container.innerHTML = `<ul class="list-disc list-inside space-y-1">${listHtml}</ul>`;
            });
        }
        // --- END NEW FUNCTION ---


        <!-- CHART 1: QUADRANT CHART (REMOVED) -->
        <!-- CHART 1.B: QUADRANT CHART (NO AXES) (REMOVED) -->


        <!-- CHART 1.5: Quadrant Chart (Rectangle Avg) -->
        function drawQuadrantChartRectangle(scores) {
            const chartContainer = document.getElementById('quadrant-chart-rect-container');
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#quadrant-chart-rect")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html(""); // Clear existing content

            const centerX = width / 2;
            const centerY = height / 2;

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6", quadrant: 'top-left' },
                { name: "Red", value: scores.red, color: "#EF4444", quadrant: 'top-right' },
                { name: "Green", value: scores.green, color: "#22C55E", quadrant: 'bottom-left' },
                { name: "Yellow", value: scores.yellow, color: "#FACC15", quadrant: 'bottom-right' }
            ];
            
            // Map color name to hex value for dynamic use
            const colorMap = {
                'Blue': '#3B82F6',
                'Red': '#EF4444',
                'Green': '#22C55E',
                'Yellow': '#FACC15'
            };

            // --- CHANGE: 1.5x area scaling (Max side length = sqrt(240/1.5) = sqrt(160)) ---
            const maxPossibleScore = 160; 
            const maxPossibleSide = Math.sqrt(maxPossibleScore);
            const maxRadius = Math.min(width / 2, height / 2) * 1.0; 
            const scale = maxRadius / maxPossibleSide; 

            const averageScore = 120;
            const averageSide = Math.sqrt(averageScore);
            const averageScaledSide = averageSide * scale; // This is the 'radius' for the rect
            
            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);
            
            // --- UPDATED ARROWHEAD DEFINITION (Smaller and Black Color) ---
            const ARROW_PATH = "M0,0 L10,5 L0,10 Z";
            const MARKER_SIZE = 3; // Much smaller arrow size (was 8)
            const ARROW_COLOR = "#000000"; // Black color

            // Define the shared marker path. We use a single definition and set fill/stroke to black.
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 0 10 10")
                .attr("refX", 10) 
                .attr("refY", 5) 
                .attr("markerWidth", MARKER_SIZE)
                .attr("markerHeight", MARKER_SIZE)
                .attr("orient", "auto-start-reverse") 
                .append("path")
                .attr("d", ARROW_PATH)
                .attr("fill", ARROW_COLOR) 
                .attr("stroke", ARROW_COLOR) 
                .attr("stroke-width", 0.5); 
            
            // --- Draw the squares FIRST ---
            data.forEach(d => {
                d.side = Math.sqrt(d.value);
                const scaledSide = d.side * scale; 
                const colorHex = colorMap[d.name];

                let x, y, textX, textY;
                switch (d.quadrant) {
                    case 'top-left': x = -scaledSide; y = -scaledSide; textX = -scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'top-right': x = 0; y = -scaledSide; textX = scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'bottom-left': x = -scaledSide; y = 0; textX = -scaledSide / 2; textY = scaledSide / 2; break;
                    case 'bottom-right': x = 0; y = 0; textX = scaledSide / 2; textY = scaledSide / 2; break;
                }

                chartGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", scaledSide)
                    .attr("height", scaledSide)
                    .attr("fill", d.color);

                if (scaledSide > 60) {
                    chartGroup.append("text")
                        .attr("class", "chart-label-title")
                        .attr("x", textX)
                        .attr("y", textY - 10)
                        .text(d.name);
                    chartGroup.append("text")
                        .attr("class", "chart-label-score") 
                        .attr("x", textX)
                        .attr("y", textY + 16)
                        .text(d.value);
                }

                // --- DYNAMIC ARROW LOGIC (Connection from Score Box to Average Box) ---
                const THRESHOLD = 24; // Points difference threshold
                
                if (Math.abs(d.value - averageScore) > THRESHOLD) { 
                    let Sx, Sy; // Start point (Corner of the Score Box)
                    let Ex, Ey; // End point (Corner of the Average Box)
                    
                    // 1. Define Corner Points 
                    switch (d.quadrant) {
                        case 'top-left': // Blue Quadrant
                            Sx = -scaledSide; Sy = -scaledSide;
                            Ex = -averageScaledSide; Ey = -averageScaledSide;
                            break;
                        case 'top-right': // Red Quadrant
                            Sx = scaledSide; Sy = -scaledSide;
                            Ex = averageScaledSide; Ey = -averageScaledSide;
                            break;
                        case 'bottom-left': // Green Quadrant
                            Sx = -scaledSide; Sy = scaledSide;
                            Ex = -averageScaledSide; Ey = averageScaledSide;
                            break;
                        case 'bottom-right': // Yellow Quadrant
                            Sx = scaledSide; Sy = scaledSide;
                            Ex = averageScaledSide; Ey = averageScaledSide;
                            break;
                    }

                    // 2. Draw the line connecting the score box corner to the average box corner
                    chartGroup.append("line")
                        .attr("x1", Sx)
                        .attr("y1", Sy)
                        .attr("x2", Ex)
                        .attr("y2", Ey)
                        .attr("stroke", ARROW_COLOR) // Use black color
                        .attr("stroke-width", 2) // Slightly thicker line
                        .attr("marker-end", "url(#arrowhead)") 
                        .attr("style", `color: ${ARROW_COLOR};`); // Set currentColor context for the marker
                }
                // --- END DYNAMIC ARROW LOGIC ---
            });

            // --- Draw the axes to divide colors ---
            const axisColor = "#4b5563"; // gray-600
            const axisWidth = 2;
            
            // Y-axis (vertical)
            chartGroup.append("line")
                .attr("x1", 0)
                .attr("y1", -maxRadius)
                .attr("x2", 0)
                .attr("y2", maxRadius)
                .attr("stroke", axisColor)
                .attr("stroke-width", axisWidth);

            // X-axis (horizontal)
            chartGroup.append("line")
                .attr("x1", -maxRadius)
                .attr("y1", 0)
                .attr("x2", maxRadius)
                .attr("y2", 0)
                .attr("stroke", axisColor)
                .attr("stroke-width", axisWidth);
            // --- END AXES ---

            // --- Draw the average RECTANGLE LAST (so it's on top) ---
            chartGroup.append("rect")
                .attr("x", -averageScaledSide)
                .attr("y", -averageScaledSide)
                .attr("width", averageScaledSide * 2)
                .attr("height", averageScaledSide * 2)
                .attr("fill", "none")
                .attr("stroke", "#6b7280") // gray-500
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4 4"); // Make it dashed
        }
        // --- END FUNCTION ---

        <!-- NEW: Chart 1.6: Quadrant Chart (Words) ---
        function drawQuadrantChartWords(scores, rankedWords) {
            const chartContainer = document.getElementById('quadrant-chart-words-container'); // New container
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#quadrant-chart-words") // New SVG ID
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const centerX = width / 2;
            const centerY = height / 2;
            
            // --- UPDATED COLORS for better contrast/design ---
            const data = [
                { name: "Blue", value: scores.blue, color: "#C6DAF8", quadrant: 'top-left' }, // Light Blue
                { name: "Red", value: scores.red, color: "#FDDCDC", quadrant: 'top-right' }, // Light Red/Rose
                { name: "Green", value: scores.green, color: "#C3E6CB", quadrant: 'bottom-left' }, // Light Green
                { name: "Yellow", value: scores.yellow, color: "#FEEFC3", quadrant: 'bottom-right' } // Light Yellow/Gold
            ];

            <!-- Max score set to 120 for 2x area scaling -->
            const maxPossibleScore = 160; 
            const maxPossibleSide = Math.sqrt(maxPossibleScore);
            const maxRadius = Math.min(width / 2, height / 2) * 1.0; 
            const scale = maxRadius / maxPossibleSide; // <-- ADDED THIS LINE TO FIX ERROR

            const averageScore = 120;
            const averageSide = Math.sqrt(averageScore);
            const averageScaledSide = averageSide * scale;
            
            const ARROW_SIZE = 15;
            // Path for a standard UP arrow
            const pathUp = `M 0,${-ARROW_SIZE / 2} L ${ARROW_SIZE / 2},${ARROW_SIZE / 2} L ${-ARROW_SIZE / 2},${ARROW_SIZE / 2} Z`;
            // Path for a standard DOWN arrow (inverted Y coordinates)
            const pathDown = `M 0,${ARROW_SIZE / 2} L ${ARROW_SIZE / 2},${-ARROW_SIZE / 2} L ${-ARROW_SIZE / 2},${-ARROW_SIZE / 2} Z`;


            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            // --- Draw the squares FIRST ---
            data.forEach(d => {
                d.side = Math.sqrt(d.value);
                const scaledSide = d.side * scale; 

                let x, y;
                switch (d.quadrant) {
                    case 'top-left': x = -scaledSide; y = -scaledSide; break;
                    case 'top-right': x = 0; y = -scaledSide; break;
                    case 'bottom-left': x = -scaledSide; y = 0; break;
                    case 'bottom-right': x = 0; y = 0; break;
                }

                // Draw the colored rectangle
                chartGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", scaledSide)
                    .attr("height", scaledSide)
                    .attr("fill", d.color);

                // --- NEW TEXT LOGIC ---
                const colorName = d.name.toLowerCase();
                const wordCapacity = Math.floor(d.value / 20);
                // Get the words for this color, up to its capacity
                const wordsToShow = rankedWords[colorName].slice(0, wordCapacity);

                if (wordsToShow.length > 0) {
                    
                    // --- Dynamic Font Size Calculation ---
                    const totalWords = wordsToShow.length;
                    
                    // Define constraints for the font size (in pixels)
                    const maxFontSizePx = 20;
                    const minFontSizePx = 10;
                    const verticalPadding = 20; // 10px top/bottom padding
                    const lineHeightFactor = 1.4;

                    // Calculate the size needed if each word takes up one row
                    const usableHeight = scaledSide - verticalPadding;
                    const requiredLineHeight = usableHeight / totalWords;
                    
                    // Calculate a target font size based on the required line height (dividing by line height factor)
                    let targetFontSizePx = requiredLineHeight / lineHeightFactor;

                    // Clamp the target font size between min and max constraints
                    let dynamicFontSizePx = Math.max(minFontSizePx, Math.min(maxFontSizePx, targetFontSizePx));
                    
                    let baseFontSize = `${dynamicFontSizePx}px`; 
                    
                    // --- End Dynamic Font Size Calculation ---

                    // --- Font and Layout Logic ---
                    let fontFamily = 'sans-serif';
                    let fontWeight = 'normal';
                    let fontSize = baseFontSize; // Use the dynamic size

                    switch (colorName) {
                        case 'blue':
                            fontFamily = 'sans-serif';
                            fontWeight = '300'; // Thin font
                            break;
                        case 'red':
                            fontFamily = 'sans-serif';
                            fontWeight = '900'; // Bold font
                            break;
                        case 'green':
                            fontFamily = "'Times New Roman', Times, serif"; // Serif font
                            fontWeight = 'normal'; // Will vary by rank
                            break;
                        case 'yellow':
                            fontFamily = "'Cursive', cursive"; // Calligraphy/Script font
                            fontWeight = 'normal'; // Will vary by rank
                            // Script font often needs more space, so scale it up slightly if possible
                            fontSize = `${dynamicFontSizePx * 1.1}px`; 
                            break;
                    }

                    // Build the HTML content for the words as "tags"
                    const wordsHtml = wordsToShow.map(word => {
                        
                        let finalWeight = fontWeight;
                        // For Green/Yellow, vary weight by rank. Blue/Red are fixed.
                        if (colorName === 'green' || colorName === 'yellow') {
                            if (word.rank == 1) finalWeight = '700';
                            else if (word.rank == 2) finalWeight = '500';
                            else if (word.rank == 3) finalWeight = '400';
                            else finalWeight = '300';
                        }
                        
                        // Use opacity for all to show rank (stronger differentiation)
                        let opacity = '1.0';
                        if (word.rank == 2) opacity = '0.7'; // More pronounced opacity reduction
                        else if (word.rank == 3) opacity = '0.5';
                        else if (word.rank == 4) opacity = '0.3';

                        // Use the calculated fontSize
                        const wordTagStyle = `
                            font-family: ${fontFamily}; 
                            font-weight: ${finalWeight}; 
                            font-size: ${fontSize};
                            opacity: ${opacity};
                            color: #1f2937; /* Very dark text for max contrast */
                            display: block; 
                            text-align: center;
                            line-height: 1.4; /* Set line height relative to the dynamic font size */
                        `;

                        return `<span style="${wordTagStyle.replace(/\s+/g, ' ')}">${word.text}</span>`;
                    }).join('');

                    // --- Layout Improvement: Changed to flex-direction: column and removed flex-wrap/gap ---
                    const htmlContent = `
                        <div xmlns="http://www.w3.org/1999/xhtml" 
                             style="width: ${scaledSide}px; height: ${scaledSide}px; 
                                    font-family: sans-serif; 
                                    overflow-y: hidden; 
                                    padding: 10px 5px; /* Increased top/bottom padding slightly */
                                    box-sizing: border-box;
                                    display: flex; flex-direction: column; /* Stack words vertically */
                                    align-items: center; /* Center horizontally */
                                    justify-content: center; /* Center vertically (as a group) */
                                    text-align: center;">
                            ${wordsHtml}
                        </div>
                    `;
                    // --- END NEW LOGIC ---


                    // Append the foreignObject
                    chartGroup.append("foreignObject")
                        .attr("x", x) // Position it at the same spot as the rect
                        .attr("y", y)
                        .attr("width", scaledSide) // Give it the same size
                        .attr("height", scaledSide)
                        .html(htmlContent);
                        
                }
                
            });

            // --- CHANGED: REMOVED the axes ---
            /*
            const axisColor = "#4b5563"; 
            const axisWidth = 2;
            
            chartGroup.append("line")
                .attr("x1", 0).attr("y1", -maxRadius)
                .attr("x2", 0).attr("y2", maxRadius)
                .attr("stroke", axisColor).attr("stroke-width", axisWidth);

            chartGroup.append("line")
                .attr("x1", -maxRadius).attr("y1", 0)
                .attr("x2", maxRadius).attr("y2", 0)
                .attr("stroke", axisColor).attr("stroke-width", axisWidth);
            */

            // --- CHANGED: REMOVED the average RECTANGLE ---
            /*
            chartGroup.append("rect")
                .attr("x", -averageScaledSide)
                .attr("y", -averageScaledSide)
                .attr("width", averageScaledSide * 2)
                .attr("height", averageScaledSide * 2)
                .attr("fill", "none")
                .attr("stroke", "#6b7280")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4 4");
            */
        }
        // --- END NEW FUNCTION ---


        <!-- CHART 2: AREA (TRIANGLE) CHART (REMOVED) -->
        
        <!-- CHART 3: DONUT CHART (REMOVED) -->

        <!-- CHART 4: PIE CHART -->
        function drawPieChart(scores) {
            const container = document.getElementById('pie-chart-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2 * 0.9;
            const innerRadius = 0; // The only difference from Donut Chart

            const svg = d3.select("#pie-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6" },
                { name: "Red", value: scores.red, color: "#EF4444", color: "#EF4444" },
                { name: "Green", value: scores.green, color: "#22C55E" },
                { name: "Yellow", value: scores.yellow, color: "#FACC15" }
            ].filter(d => d.value > 0);

            if (data.length === 0) return; 

            const total = d3.sum(data, d => d.value);

            const pie = d3.pie().value(d => d.value).sort(null);
            const arc = d3.arc().innerRadius(innerRadius).outerRadius(radius);

            const arcs = chartGroup.selectAll(".arc")
                .data(pie(data))
                .enter().append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("stroke", "white")
                .style("stroke-width", "2px");

            arcs.append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("dy", "0.35em")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .style("font-size", "1.1rem")
                .style("font-weight", "600")
                .style("text-shadow", "0 0 3px rgba(0,0,0,0.7)")
                .text(d => {
                    if (total === 0) return "0%";
                    const percent = (d.data.value / total) * 100;
                    return `${percent.toFixed(0)}%`;
                });
        }

        // --- DRAG AND DROP HANDLERS ---
        
        function handleDragStart(e) {
            const target = e.target.closest('.draggable-word');
            if (!target) return;
            
            draggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.textContent); // Necessary for Firefox
            setTimeout(() => target.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            // This is a cleanup function for drops that *don't* land in a valid dropzone
            // (e.g., dropped outside the window)
            // --- FIX V3: Check if item still being tracked ---
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
            }
            draggedItem = null; // Always clear on dragend
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        }

        function handleDragOver(e) {
            e.preventDefault();
            const dropzone = e.target.closest('.drop-spot, .word-bank-dropzone');
            if (dropzone) {
                // Prevent dropping a word in a full spot *that isn't the one it came from*
                if (dropzone.classList.contains('drop-spot') && dropzone.children.length > 1 && draggedItem && draggedItem.parentElement !== dropzone) {
                    // This is a full spot, don't highlight
                } else {
                    dropzone.classList.add('highlight');
                }
            }
        }

        function handleDragLeave(e) {
            const dropzone = e.target.closest('.drop-spot, .word-bank-dropzone');
            if (dropzone) {
                dropzone.classList.remove('highlight');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            
            // --- FIX V4: Use a local variable and clear global immediately ---
            if (!draggedItem) return; // A drop event somehow fired without a dragged item
            const itemToDrop = draggedItem; // "Claim" the item
            draggedItem = null; // Clear global immediately
            itemToDrop.classList.remove('dragging'); // Stop the dragging style
            // --- END FIX V4 ---

            const dropzone = e.target.closest('.drop-spot, .word-bank-dropzone');
            if (!dropzone) return; // Didn't land in a valid spot

            dropzone.classList.remove('highlight');
            const card = dropzone.closest('.question-card');
            
            // Case 1: Dropping in a Rank Spot
            if (dropzone.classList.contains('drop-spot')) {
                // If spot is already full, move existing word back to bank
                if (dropzone.children.length > 1) { // 2 children = labels + word
                    const existingWord = dropzone.querySelector('.draggable-word');
                    if (existingWord && existingWord !== itemToDrop) { // Don't move item if dropping on self
                        card.querySelector('.word-bank-dropzone').appendChild(existingWord);
                    }
                }
                dropzone.appendChild(itemToDrop); // Use local copy
                dropzone.classList.add('drop-spot-filled');
            }
            
            // Case 2: Dropping back in the Word Bank
            if (dropzone.classList.contains('word-bank-dropzone')) {
                const originalSpot = itemToDrop.closest('.drop-spot'); // Use local copy
                if (originalSpot) {
                    originalSpot.classList.remove('drop-spot-filled');
                }
                dropzone.appendChild(itemToDrop); // Use local copy
            }
            
            // Validate the card that was just changed
            if (card) {
                validateCard(card);
                
                // --- FIX for Save Button Bug ---
                if (currentQuestionIndex === totalQuestions - 1) {
                    // We are on the last question, so check ALL cards
                    // to see if the save button should be enabled.
                    checkFormCompletion(true);
                } else {
                    // We are on a normal question, just check the 'next' button.
                    checkFormCompletion(false);
                }
                // --- END FIX ---
            }
        }


        // --- INITIALIZATION & EVENT LISTENERS ---

        function initialize() {
            // Render all questions
            questionsData.forEach((words, index) => {
                const card = createQuestionCard(words, index);
                questionsContainer.appendChild(card);
            });
            
            showQuestion(currentQuestionIndex);

            // --- Global Drag and Drop Listeners ---
            document.addEventListener('dragstart', handleDragStart);
            document.addEventListener('dragend', handleDragEnd);
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleDrop);

            // --- Button Listeners ---
            saveButton.addEventListener('click', () => {
                checkFormCompletion(true); // Final check
                if (!saveButton.disabled) {
                    
                    // NEW: Collect both scores and words
                    const { scores, rankedWords } = collectRankedWords();
                    
                    testPage.classList.add('hidden');
                    resultsPage.classList.remove('hidden');

                    setTimeout(() => {
                        // NEW: Populate the Key Words section
                        populateWordAnalysis(scores, rankedWords); // <-- Pass scores in
                        
                        // Call all other charts
                        // drawQuadrantChart(scores); // <-- REMOVED
                        // drawQuadrantChartNoAxis(scores); // <-- REMOVED
                        drawQuadrantChartRectangle(scores); 
                        drawQuadrantChartWords(scores, rankedWords); // <-- ADDED THIS CALL
                        // drawDonutChart(scores); // <-- REMOVED
                        drawPieChart(scores); 
                    }, 10); 

                    successMessage.textContent = 'Answers saved and results calculated!';
                    setTimeout(() => { successMessage.textContent = ''; }, 3000);
                }
            });

            backToTestButton.addEventListener('click', () => {
                resultsPage.classList.add('hidden');
                testPage.classList.remove('hidden');
            });
            
            nextButton.addEventListener('click', () => {
                if (currentQuestionIndex < totalQuestions - 1) {
                    currentQuestionIndex++;
                    showQuestion(currentQuestionIndex);
                }
            });

            prevButton.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    showQuestion(currentQuestionIndex);
                }
            });

            devFillButton.addEventListener('click', () => {
                const allCards = document.querySelectorAll('.question-card');
                allCards.forEach(card => {
                    const wordBank = card.querySelector('.word-bank-dropzone');
                    const spots = card.querySelectorAll('.drop-spot');
                    const words = Array.from(wordBank.querySelectorAll('.draggable-word'));
                    
                    // Shuffle words
                    for (let i = words.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [words[i], words[j]] = [words[j], words[i]];
                    }
                    
                    // Place words in spots
                    words.forEach((word, index) => {
                        if (spots[index]) {
                            spots[index].appendChild(word);
                            spots[index].classList.add('drop-spot-filled');
                        }
                    });
                    validateCard(card);
                });

                successMessage.textContent = 'All answers randomly filled!';
                setTimeout(() => { successMessage.textContent = ''; }, 3000);
                
                currentQuestionIndex = totalQuestions - 1;
                showQuestion(currentQuestionIndex);
            });
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
