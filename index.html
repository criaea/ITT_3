<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Millennium Profile</title>
    <!-- Loading Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Loading D3.js for the chart --><script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* D3 Chart text styling */
        .chart-label-title {
            font-size: 1.5rem; /* Tailwind text-2xl equivalent */
            font-weight: 700; /* Tailwind font-bold equivalent */
            fill: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-anchor: middle; /* Center text horizontally */
        }
        .chart-label-score {
            font-size: 1.25rem; /* Tailwind text-xl equivalent */
            font-weight: 500; /* Tailwind font-medium equivalent */
            fill: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-anchor: middle; /* Center text horizontally */
        }
        /* D3 Radar Chart text styling */
        .radar-label {
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            text-anchor: middle;
            fill: #374151; /* gray-700 */
        }
        
        /* --- REMOVED Word Map Text Styles --- */


        /* --- New Drag and Drop Styles --- */
        /* The draggable word itself */
        .draggable-word {
            padding: 0.75rem;
            background-color: white;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            cursor: grab;
            transition: all 0.2s ease;
            text-align: center;
            font-weight: 500;
        }
        
        .draggable-word:active {
            cursor: grabbing;
        }

        /* Style for the item being dragged */
        .dragging {
            opacity: 0.5;
            background: #f0f9ff; /* light-blue-50 */
            border: 1px dashed #0284c7; /* blue-600 */
        }

        /* The empty spot to drop into */
        .drop-spot {
            padding: 1rem;
            border: 2px dashed #9ca3af; /* gray-400 */
            border-radius: 0.5rem; /* rounded-lg */
            min-height: 80px; /* Give it a minimum height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            background-color: #f9fafb; /* gray-50 */
        }
        
        .drop-spot-label {
            font-weight: 600;
            color: #4b5563; /* gray-600 */
        }
        
        .drop-spot-subtext {
            font-size: 0.875rem;
            color: #6b7280; /* gray-500 */
        }

        /* When dragging OVER a spot */
        .drop-spot.highlight,
        .word-bank-dropzone.highlight {
            background-color: #dbeafe; /* blue-100 */
            border-color: #3b82f6; /* blue-500 */
        }

        /* When a spot is FILLED */
        .drop-spot-filled {
            border-style: solid;
            border-color: #10b981; /* green-500 */
            background-color: #ecfdf5; /* green-50 */
            padding: 0.5rem; /* Reduce padding when filled */
        }

        .drop-spot-filled .drop-spot-label,
        .drop-spot-filled .drop-spot-subtext {
            display: none; /* Hide placeholder text */
        }
        
        /* The word bank on the right */
        .word-bank-dropzone {
            padding: 1rem;
            background-color: #f3f4f6; /* gray-100 */
            border: 2px solid #e5e7eb; /* gray-200 */
            border-radius: 0.5rem;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* space-y-3 */
        }

        /* --- NEW: Style for Key Words list --- */
        .key-word-rank-1 { font-weight: 700; color: #1f2937; } /* bold, gray-800 */
        .key-word-rank-2 { font-weight: 500; color: #374151; } /* medium, gray-700 */
        .key-word-rank-3 { font-weight: 400; color: #4b5563; opacity: 0.9; } /* normal, gray-600 */
        .key-word-rank-4 { font-weight: 300; color: #6b7280; opacity: 0.8; } /* light, gray-500 */
        /* --- END NEW --- */

    </style>
</head>
<body class="bg-gray-100 font-sans p-4 md:p-8 min-h-screen flex items-center justify-center">

    <!-- Main Test Page Container --><main id="test-page" class="container bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-4xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-3 text-blue-700">Millennium Profile</h1>
        <p class="text-center text-gray-600 mb-8">
            For each question, drag the words from the "Word Choices" into the slots on the right.
        </p>

        <!-- New Question Counter -->
        <p id="question-counter" class="text-center text-lg font-semibold text-gray-700 mb-4"></p>

        <!-- Questions Container --><div id="questions-container" class="space-y-6">
            <!-- All 24 questions will be rendered here by JS, but hidden -->
        </div>

        <!-- Navigation/Action Buttons -->
        <div class="mt-10 flex flex-col items-center justify-center gap-4">
            
            <!-- Developer Fill Button -->
            <button id="dev-fill-button" 
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-full sm:w-auto">
                Developer: Random Fill
            </button>
            
            <!-- Navigation buttons -->
            <div class="flex flex-row justify-center gap-4 w-full sm:w-auto">
                <button id="prev-button" 
                        class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-1/2 sm:w-auto">
                    Previous
                </button>
                <button id="next-button" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-1/2 sm:w-auto"
                        disabled>
                    Next
                </button>
            </div>
            
            <!-- Save Button (hidden initially) -->
            <button id="save-button" 
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto"
                    disabled style="display: none;">
                Show Results
            </button>
        </div>
        <p id="error-message" class="text-red-600 font-semibold mt-4 h-6 text-center"></p>
        <p id="success-message" class="text-green-600 font-semibold mt-4 h-6 text-center"></p>
    </main>

    <!-- Results Page Container (hidden by default) 
    --><div id="results-page" class="hidden fixed inset-0 bg-gray-100 p-4 overflow-y-auto">
        <div class="container bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-5xl mx-auto flex flex-col items-center my-auto">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-blue-700">Your Profile Results</h1>
            
            <!-- NEW: Grid container for multiple charts -->
            <div class="grid grid-cols-1 md:grid-cols-1 gap-8 w-full">

                <!-- REMOVED: Chart 0: Word Map Chart -->
                
                <!-- NEW: Key Words Section -->
                <div class="w-full">
                    <h2 class="text-3xl font-bold text-center text-gray-800 mb-6">Your Key Words (Ranked #1 & #2)</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-px bg-gray-300 rounded-lg shadow-md overflow-hidden">
                        
                        <!-- BLUE (Upper Left) -->
                        <div class="bg-blue-100 p-6">
                            <h3 class="text-2xl font-bold text-blue-800 mb-3">BLUE</h3>
                            <div id="blue-key-words"></div>
                        </div>

                        <!-- RED (Upper Right) -->
                        <div class="bg-red-100 p-6">
                            <h3 class="text-2xl font-bold text-red-800 mb-3">RED</h3>
                            <div id="red-key-words"></div>
                        </div>

                        <!-- GREEN (Lower Left) -->
                        <div class="bg-green-100 p-6">
                            <h3 class="text-2xl font-bold text-green-800 mb-3">GREEN</h3>
                            <div id="green-key-words"></div>
                        </div>

                        <!-- YELLOW (Lower Right) -->
                        <div class="bg-yellow-100 p-6">
                            <h3 class="text-2xl font-bold text-yellow-800 mb-3">YELLOW</h3>
                            <div id="yellow-key-words"></div>
                        </div>
                    </div>
                </div>
                <!-- END NEW Section -->


                <!-- Chart 1: Quadrant Chart (Circle Avg, with Axes) -->
                <div class="bg-gray-50 rounded-lg p-4 shadow-inner">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Quadrant Chart (With Axes)</h2>
                    <div id="quadrant-chart-container" class="w-full h-[60vh] overflow-hidden">
                        <svg id="quadrant-chart" class="w-full h-full"></svg>
                    </div>
                </div>

                <!-- NEW: Chart 1.B: Quadrant Chart (Circle Avg, No Axes) -->
                <div class="bg-gray-50 rounded-lg p-4 shadow-inner">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Quadrant Chart (No Axes)</h2>
                    <div id="quadrant-chart-noaxis-container" class="w-full h-[60vh] overflow-hidden">
                        <svg id="quadrant-chart-noaxis" class="w-full h-full"></svg>
                    </div>
                </div>

                <!-- Chart 1.5: Quadrant Chart (Rectangle Avg) -->
                <div class="bg-gray-50 rounded-lg p-4 shadow-inner">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Quadrant Chart (Rectangle Average)</h2>
                    <div id="quadrant-chart-rect-container" class="w-full h-[60vh] overflow-hidden">
                        <svg id="quadrant-chart-rect" class="w-full h-full"></svg>
                    </div>
                </div>

                <!-- Chart 3: Donut Chart -->
                <div class="bg-gray-50 rounded-lg p-4 shadow-inner">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Donut Chart (Proportions)</h2>
                    <div id="donut-chart-container" class="w-full h-[50vh] overflow-hidden">
                        <svg id="donut-chart" class="w-full h-full"></svg>
                    </div>
                </div>

                <!-- Chart 4: Pie Chart -->
                <div class="bg-gray-50 rounded-lg p-4 shadow-inner">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Pie Chart (Proportions)</h2>
                    <div id="pie-chart-container" class="w-full h-[50vh] overflow-hidden">
                        <svg id="pie-chart" class="w-full h-full"></svg>
                    </div>
                </div>

            </div>

            <!-- Profile Analysis Section -->
            <div class="w-full mt-12">
                <h2 class="text-3xl font-bold text-center text-gray-800 mb-6">Your Profile Analysis</h2>
                <!-- This is now a single container with a 2x2 grid inside -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-px bg-gray-300 rounded-lg shadow-md overflow-hidden">
                    
                    <!-- BLUE (Upper Left) -->
                    <div class="bg-blue-100 p-6"> <!-- Fixed typo classV and removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-blue-800 mb-3">BLUE (Upper Left)</h3>
                        <ul class="list-disc list-inside text-blue-900 space-y-1">
                            <li>Wants to see data and statistics on performance.</li>
                            <li>Looks at energy efficiency.</li>
                            <li>Looks at cost of vehicle, trade in value.</li>
                            <li>Comparison shopping with other vehicles.</li>
                            <li>Ease of maintenance.</li>
                            <li>Wants to know how it works.</li>
                            <li>Likes power and precision handling.</li>
                        </ul>
                    </div>

                    <!-- RED (Upper Right) -->
                    <div class="bg-red-100 p-6"> <!-- Removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-red-800 mb-3">RED (Upper Right)</h3>
                        <ul class="list-disc list-inside text-red-900 space-y-1">
                            <li>Looks at the aesthetic qualities: sportiness, colour, form. "Cutting Edge" qualities.</li>
                            <li>Wants it to fit the dream, personal image, long range plans.</li>
                            <li>More willing to experiment and take some risks.</li>
                            <li>1st model buyer, early innovator.</li>
                        </ul>
                    </div>

                    <!-- GREEN (Lower Left) -->
                    <div class="bg-green-100 p-6"> <!-- Removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-green-800 mb-3">GREEN (Lower Left)</h3>
                        <ul class="list-disc list-inside text-green-900 space-y-1">
                            <li>Interested in safety features, and durability.</li>
                            <li>The practicality of size, number of doors, storage space, strain resistant materials, features such as interior trunk/gas lock.</li>
                            <li>Looks at maintenance requirements.</li>
                            <li>Have done research and know what they want.</li>
                        </ul>
                    </div>

                    <!-- YELLOW (Lower Right) -->
                    <div class="bg-yellow-100 p-6"> <!-- Removed rounding/shadow -->
                        <h3 class="text-2xl font-bold text-yellow-800 mb-3">YELLOW (Lower Right)</h3>
                        <ul class="list-disc list-inside text-yellow-900 space-y-1">
                            <li>The 'Feel' and comfort of the vehicle is important, user friendliness of controls.</li>
                            <li>Wants to 'Love' the car.</li>
                            <li>Impacted by friendliness of sale and service organisation.</li>
                            <li>Knows it's a right choice.</li>
                            <li>Will buy based on a friends recommendations.</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="text-center mt-12"> <!-- Added more margin-top -->
                <button id="back-to-test-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300">
                    Back to Test
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- PAGE ELEMENTS ---
        const testPage = document.getElementById('test-page');
        const resultsPage = document.getElementById('results-page');
        const questionsContainer = document.getElementById('questions-container');
        const saveButton = document.getElementById('save-button');
        const successMessage = document.getElementById('success-message');
        const errorMessage = document.getElementById('error-message');
        const backToTestButton = document.getElementById('back-to-test-button');
        const devFillButton = document.getElementById('dev-fill-button');
        
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const questionCounter = document.getElementById('question-counter');

        // --- STATE ---
        let currentQuestionIndex = 0;
        const totalQuestions = 24;
        let draggedItem = null;

        // --- QUESTION DATA ---
        const questionsData = [
            // Q1
            [
                { word: "Gentle, Kindly", color: "green" },
                { word: "Persuasive, Convincing", color: "yellow" },
                { word: "Humble, reserved", color: "blue" },
                { word: "Original, inventive", color: "red" }
            ],
            // Q2
            [
                { word: "Attractive, charming", color: "yellow" },
                { word: "Cooperative, agreeable", color: "blue" },
                { word: "Stubborn, unyielding", color: "red" },
                { word: "Pleasing, Pleasant", color: "green" }
            ],
            // Q3
            [
                { word: "Easily lead, follower", color: "blue" },
                { word: "Bold, daring", color: "red" },
                { word: "Loyal, faithful", color: "green" },
                { word: "Charming, delightful", color: "yellow" }
            ],
            // Q4
            [
                { word: "Open-minded, receptive", color: "blue" },
                { word: "Obliging, helpful", color: "green" },
                { word: "Will power, strong willed", color: "red" },
                { word: "Cheerful, joyful", color: "yellow" }
            ],
            // Q5
            [
                { word: "Jovial, jolting", color: "yellow" },
                { word: "Precise, exact", color: "blue" },
                { word: "Gutsy, brazen", color: "red" },
                { word: "Even tempered, calm", color: "green" }
            ],
            // Q6
            [
                { word: "Competitive, seeking to win", color: "red" },
                { word: "Considerate, caring, thoughtful", color: "green" },
                { word: "Outgoing, fun loving", color: "yellow" },
                { word: "Harmonious, agreeable", color: "blue" }
            ],
            // Q7
            [
                { word: "Fussy, hard to please", color: "blue" },
                { word: "Obedient, dutiful", color: "green" },
                { word: "Unconquerable, determined", color: "red" },
                { word: "Playful, full of fun", color: "yellow" }
            ],
            // Q8
            [
                { word: "Brave, courageous", color: "red" },
                { word: "Inspiring, motivating", color: "yellow" },
                { word: "Submissive, yielding", color: "green" },
                { word: "Timid, shy quiet", color: "blue" }
            ],
            // Q9
            [
                { word: "Sociable", color: "yellow" },
                { word: "Patient", color: "green" }, // <-- FIX 1 HERE
                { word: "Self reliant, independent", color: "red" },
                { word: "Mild, reserved", color: "blue" }
            ],
            // Q10
            [
                { word: "Adventurous", color: "red" },
                { word: "Receptive, open to suggestions", color: "green" },
                { word: "Warm, friendly", color: "yellow" },
                { word: "Moderate", color: "blue" }
            ],
            // Q11
            [
                { word: "Talkative, chatty", color: "yellow" },
                { word: "Controlled, restrained", color: "green" },
                { word: "Conventional", color: "blue" },
                { word: "Decisive, certain", color: "red" }
            ],
            // Q12
            [
                { word: "Polished, smooth talker", color: "yellow" },
                { word: "Daring, risk-taker", color: "red" },
                { word: "Diplomatic, tactful", color: "blue" },
                { word: "Satisfied, content", color: "green" }
            ],
            // Q13
            [
                { word: "Aggressive, challenger", color: "red" },
                { word: "Outgoing, entertaining", color: "yellow" },
                { word: "Easy mark, easily taken advantage of", color: "green" },
                { word: "Fearful, afraid", color: "blue" }
            ],
            // Q14
            [
                { word: "Cautious, wary", color: "blue" },
                { word: "Determined, decided", color: "red" },
                { word: "Convincing, assuring", color: "yellow" },
                { word: "Good-natured, pleasant", color: "green" }
            ],
            // Q15
            [
                { word: "Willing, compliant", color: "green" },
                { word: "Eager, anxious", color: "yellow" },
                { word: "Agreeable, Consenting", color: "blue" },
                { word: "High-spirited, lively, enthusiastic", color: "red" }
            ],
            // Q16
            [
                { word: "Confident, assured", color: "yellow" },
                { word: "Sympathetic, compassionate", color: "green" },
                { word: "Tolerant", color: "blue" },
                { word: "Assertive, aggressive", color: "red" }
            ],
            // Q17
            [
                { word: "Well disciplined, self-controlled", color: "blue" },
                { word: "Generous, willing to share", color: "green" },
                { word: "Animated, uses gestures for expression", color: "yellow" },
                { word: "Persistent, unrelenting", color: "red" }
            ],
            // Q18
            [
                { word: "Brave, courageous", color: "red" },
                { word: "Inspiring, motivating", color: "yellow" },
                { word: "Submissive, yielding", color: "blue" },
                { word: "Timid, shy quiet", color: "green" }
            ],
            // Q19
            [
                { word: "Respectful", color: "blue" },
                { word: "Pioneering, exploring", color: "red" },
                { word: "Optimistic, positive", color: "yellow" },
                { word: "Accommodating, willing to please", color: "green" }
            ],
            // Q20
            [
                { word: "Argumentative, Controlling", color: "red" },
                { word: "Adaptable, flexible", color: "green" },
                { word: "Nonchalant, indifferent", color: "blue" }, // <-- FIX 2 HERE
                { word: "Light-hearted, carefree", color: "yellow" }
            ],
            // Q21
            [
                { word: "Trusting, faith in others", color: "yellow" },
                { word: "Contented, satisfied", color: "green" },
                { word: "Positive, sure", color: "red" },
                { word: "Peaceful, tranquil", color: "blue" }
            ],
            // Q22
            [
                { word: "Good mixer, sociable", color: "yellow" },
                { word: "Educated, Knowledgeable", color: "blue" },
                { word: "Vigorous, energetic", color: "red" },
                { word: "Lenient", color: "green" }
            ],
            // Q23
            [
                { word: "Companionable", color: "yellow" },
                { word: "Accurate, correct", color: "blue" },
                { word: "Outspoken, speaks freely", color: "red" },
                { word: "Restrained, reserved, controlled", color: "green" }
            ],
            // Q24
            [
                { word: "Restless, unable to rest or relax", color: "red" },
                { word: "Neighborly, friendly", color: "green" },
                { word: "Popular, liked by many", color: "yellow" },
                { word: "Neat, organized", color: "blue" }
            ]
        ];

        // --- QUESTION CARD FUNCTIONS ---

        function createDraggableWord(word, color) {
            const wordDiv = document.createElement('div');
            wordDiv.className = 'draggable-word';
            wordDiv.draggable = true;
            wordDiv.textContent = word;
            wordDiv.dataset.color = color;
            return wordDiv;
        }

        function createQuestionCard(questionWords, index) {
            const card = document.createElement('div');
            card.className = 'question-card bg-white border border-gray-200 rounded-lg p-5 shadow-sm';
            card.dataset.questionId = index;
            card.dataset.status = 'invalid'; // Invalid by default
            
            if (index !== 0) {
                card.style.display = 'none';
            }
            
            // Create word bank items
            const wordBankWords = questionWords.map(item => createDraggableWord(item.word, item.color).outerHTML).join('');

            card.innerHTML = `
                <h2 class="text-xl font-semibold text-gray-900 mb-2">Question ${index + 1}</h2>
                <p class="text-gray-600 mb-4 text-sm">Drag the words from the "Word Choices" (left) into "Your Order" slots (right).</p>
                <div class="flex flex-col md:flex-row gap-6">
                    
                    <!-- Left Column: Word Bank -->
                    <div class="flex-1">
                         <h3 class="font-semibold text-gray-700">Word Choices:</h3>
                         <div class="word-bank-dropzone mt-2">
                            ${wordBankWords}
                         </div>
                    </div>
                    
                    <!-- Right Column: Rank Spots -->
                    <div class="flex-1 space-y-3">
                        <h3 class="font-semibold text-gray-700">Your Order:</h3>
                        <div class="drop-spot" data-rank="1">
                            <span class="drop-spot-label">1st Place</span>
                            <span class="drop-spot-subtext">(Most like you)</span>
                        </div>
                        <div class="drop-spot" data-rank="2">
                            <span class="drop-spot-label">2nd Place</span>
                        </div>
                        <div class="drop-spot" data-rank="3">
                            <span class="drop-spot-label">3rd Place</span>
                        </div>
                        <div class="drop-spot" data-rank="4">
                            <span class="drop-spot-label">4th Place</span>
                            <span class="drop-spot-subtext">(Least like you)</span>
                        </div>
                    </div>
                    
                </div>
                <div class="error-message text-red-600 text-sm font-medium mt-3 h-5"></div>
            `;
            return card;
        }

        // --- NAVIGATION FUNCTION ---

        function showQuestion(index) {
            const allCards = document.querySelectorAll('.question-card');
            allCards.forEach(card => {
                card.style.display = 'none';
            });
            if (allCards[index]) {
                allCards[index].style.display = 'block';
            }
            questionCounter.textContent = `Question ${index + 1} of ${totalQuestions}`;
            prevButton.disabled = (index === 0);
            
            if (index === totalQuestions - 1) {
                nextButton.style.display = 'none';
                saveButton.style.display = 'inline-flex';
                // Final check for all cards before enabling save
                checkFormCompletion(true);
            } else {
                nextButton.style.display = 'inline-flex';
                saveButton.style.display = 'none';
                // Check current card to enable next
                checkFormCompletion(false);
            }
        }

        // --- VALIDATION FUNCTIONS ---

        function validateCard(card) {
            const bank = card.querySelector('.word-bank-dropzone');
            const wordsLeft = bank.querySelectorAll('.draggable-word').length;
            const errorMessage = card.querySelector('.error-message');
            
            if (wordsLeft === 0) {
                card.dataset.status = 'valid';
                if (errorMessage) errorMessage.textContent = '';
                return true;
            } else {
                card.dataset.status = 'invalid';
                if (errorMessage) errorMessage.textContent = `You still need to assign ${wordsLeft} words.`;
                return false;
            }
        }

        function checkFormCompletion(checkAll = false) {
            const allCards = document.querySelectorAll('.question-card');
            if (checkAll) {
                // Check all cards for the final save button
                let allValid = true;
                allCards.forEach(card => {
                    if (card.dataset.status !== 'valid') {
                        allValid = false;
                    }
                });
                saveButton.disabled = !allValid;
            } else {
                // Check only the current card for the 'next' button
                const currentCard = allCards[currentQuestionIndex];
                if (currentCard) {
                    nextButton.disabled = (currentCard.dataset.status === 'invalid');
                }
            }
        }

        // --- CALCULATION & CHARTING FUNCTIONS ---

        // NEW: Collects scores AND ranked word list
        function collectRankedWords() {
            const pointMap = { "1": 10, "2": 6, "3": 3, "4": 1 };
            let scores = { blue: 0, red: 0, green: 0, yellow: 0 };
            // This will hold all words, sorted by color
            let rankedWords = { 
                blue: [], 
                red: [], 
                green: [], 
                yellow: [] 
            };
            
            const allCards = document.querySelectorAll('.question-card');
            
            allCards.forEach(card => {
                const spots = card.querySelectorAll('.drop-spot');
                spots.forEach(spot => {
                    const rank = spot.dataset.rank; // "1", "2", "3", "4"
                    const word = spot.querySelector('.draggable-word');
                    if (word) {
                        const color = word.dataset.color;
                        const points = pointMap[rank];
                        if (color && points != null) {
                            // 1. Add to total score
                            scores[color] += points;
                            // 2. Add to ranked word list
                            rankedWords[color].push({
                                text: word.textContent,
                                rank: rank
                            });
                        }
                    }
                });
            });
            
            // Sort each color's word list by rank
            for (const color in rankedWords) {
                rankedWords[color].sort((a, b) => a.rank - b.rank);
            }
            
            return { scores, rankedWords };
        }

        // DEPRECATED: calculateScores() is now part of collectRankedWords()
        function calculateScores() {
            // This function is no longer called, but we leave it
            // just in case.
            const data = collectRankedWords();
            return data.scores;
        }

        // --- REMOVED: CHART 0: WORD MAP CHART ---
        
        // --- NEW: Function to populate Key Words ---
        function populateWordAnalysis(scores, rankedWords) { // <-- Now receives scores
            const colors = ['blue', 'red', 'green', 'yellow'];
            colors.forEach(color => {
                const container = document.getElementById(`${color}-key-words`);
                if (!container) return;

                // 1. Calculate word capacity based on 20 points per word
                const wordCapacity = Math.floor(scores[color] / 20); // <-- UPDATED RULE

                // 2. Get all ranked words (they are already sorted by rank from collectRankedWords)
                const allRankedWords = rankedWords[color];

                // 3. Fill the list based on capacity
                // This automatically takes #1s, then #2s, then #3s, etc., up to the limit
                let wordsToDisplay = allRankedWords.slice(0, wordCapacity);


                if (wordsToDisplay.length === 0) {
                     if (scores[color] > 0) {
                         // This handles cases where score is > 0 but < 20
                        container.innerHTML = `<p class="text-sm italic text-gray-600">No words to display at this point level.</p>`;
                    } else {
                        container.innerHTML = `<p class="text-sm italic text-gray-600">No score for this color.</p>`;
                    }
                    return;
                }

                // 5. Create the simple bulleted list
                const listHtml = wordsToDisplay.map(word => {
                    // Add a style based on rank
                    return `<li class="key-word-rank-${word.rank}">${word.text}</li>`;
                }).join('');
                
                container.innerHTML = `<ul class="list-disc list-inside space-y-1">${listHtml}</ul>`;
            });
        }
        // --- END NEW FUNCTION ---


        // --- CHART 1: QUADRANT CHART ---
        function drawQuadrantChart(scores) {
            const chartContainer = document.getElementById('quadrant-chart-container');
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#quadrant-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const centerX = width / 2;
            const centerY = height / 2;

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6", quadrant: 'top-left' },
                { name: "Red", value: scores.red, color: "#EF4444", quadrant: 'top-right' },
                { name: "Green", value: scores.green, color: "#22C55E", quadrant: 'bottom-left' },
                { name: "Yellow", value: scores.yellow, color: "#FACC15", quadrant: 'bottom-right' } // <-- CHANGED COLOR
            ];

            // --- NEW LOGIC: Scale based on MAX possible score (240) ---
            const maxPossibleScore = 240;
            const maxPossibleSide = Math.sqrt(maxPossibleScore);
            const maxRadius = Math.min(width / 2, height / 2) * 0.95; // 95% of container
            const scale = maxRadius / maxPossibleSide; // This is our pixels-per-sqrt(point)

            // --- NEW LOGIC: Calculate Average Circle ---
            const averageScore = 120;
            const averageSide = Math.sqrt(averageScore);
            const averageRadius = averageSide * scale;
            // --- END NEW LOGIC ---

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            // --- Draw the squares FIRST ---
            data.forEach(d => {
                // Calculate side length based on actual value
                d.side = Math.sqrt(d.value);
                const scaledSide = d.side * scale; // Use the new fixed scale

                let x, y, textX, textY;
                switch (d.quadrant) {
                    case 'top-left': x = -scaledSide; y = -scaledSide; textX = -scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'top-right': x = 0; y = -scaledSide; textX = scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'bottom-left': x = -scaledSide; y = 0; textX = -scaledSide / 2; textY = scaledSide / 2; break;
                    case 'bottom-right': x = 0; y = 0; textX = scaledSide / 2; textY = scaledSide / 2; break;
                }

                chartGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", scaledSide)
                    .attr("height", scaledSide)
                    .attr("fill", d.color);

                if (scaledSide > 60) {
                    chartGroup.append("text")
                        .attr("class", "chart-label-title")
                        .attr("x", textX)
                        .attr("y", textY - 10)
                        .text(d.name);
                    chartGroup.append("text")
                        .attr("class", "chart-label-score")
                        .attr("x", textX)
                        .attr("y", textY + 16)
                        .text(d.value);
                }
            });

            // --- NEW: Draw the axes to divide colors ---
            const axisColor = "#4b5563"; // gray-600
            const axisWidth = 2;
            
            // Y-axis (vertical)
            chartGroup.append("line")
                .attr("x1", 0)
                .attr("y1", -maxRadius)
                .attr("x2", 0)
                .attr("y2", maxRadius)
                .attr("stroke", axisColor)
                .attr("stroke-width", axisWidth);

            // X-axis (horizontal)
            chartGroup.append("line")
                .attr("x1", -maxRadius)
                .attr("y1", 0)
                .attr("x2", maxRadius)
                .attr("y2", 0)
                .attr("stroke", axisColor)
                .attr("stroke-width", axisWidth);
            // --- END NEW ---

            // --- Draw the average circle LAST (so it's on top) ---
            chartGroup.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", averageRadius)
                .attr("fill", "none")
                .attr("stroke", "#6b7280") // gray-500
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4 4"); // Make it dashed
        }

        // --- NEW: CHART 1.B: QUADRANT CHART (NO AXES) ---
        function drawQuadrantChartNoAxis(scores) {
            const chartContainer = document.getElementById('quadrant-chart-noaxis-container');
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#quadrant-chart-noaxis")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const centerX = width / 2;
            const centerY = height / 2;

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6", quadrant: 'top-left' },
                { name: "Red", value: scores.red, color: "#EF4444", quadrant: 'top-right' },
                { name: "Green", value: scores.green, color: "#22C55E", quadrant: 'bottom-left' },
                { name: "Yellow", value: scores.yellow, color: "#FACC15", quadrant: 'bottom-right' }
            ];

            const maxPossibleScore = 240;
            const maxPossibleSide = Math.sqrt(maxPossibleScore);
            const maxRadius = Math.min(width / 2, height / 2) * 0.95; 
            const scale = maxRadius / maxPossibleSide; 

            const averageScore = 120;
            const averageSide = Math.sqrt(averageScore);
            const averageRadius = averageSide * scale;

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            // --- Draw the squares FIRST ---
            data.forEach(d => {
                d.side = Math.sqrt(d.value);
                const scaledSide = d.side * scale; 

                let x, y, textX, textY;
                switch (d.quadrant) {
                    case 'top-left': x = -scaledSide; y = -scaledSide; textX = -scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'top-right': x = 0; y = -scaledSide; textX = scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'bottom-left': x = -scaledSide; y = 0; textX = -scaledSide / 2; textY = scaledSide / 2; break;
                    case 'bottom-right': x = 0; y = 0; textX = scaledSide / 2; textY = scaledSide / 2; break;
                }

                chartGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", scaledSide)
                    .attr("height", scaledSide)
                    .attr("fill", d.color);

                if (scaledSide > 60) {
                    chartGroup.append("text")
                        .attr("class", "chart-label-title")
                        .attr("x", textX)
                        .attr("y", textY - 10)
                        .text(d.name);
                    chartGroup.append("text")
                        .attr("class", "chart-label-score")
                        .attr("x", textX)
                        .attr("y", textY + 16)
                        .text(d.value);
                }
            });

            // --- AXES ARE REMOVED IN THIS VERSION ---

            // --- Draw the average circle LAST (so it's on top) ---
            chartGroup.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", averageRadius)
                .attr("fill", "none")
                .attr("stroke", "#6b7280") // gray-500
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4 4"); // Make it dashed
        }
        // --- END NEW FUNCTION ---


        // --- CHART 1.5: QUADRANT CHART (RECTANGLE) ---
        function drawQuadrantChartRectangle(scores) {
            const chartContainer = document.getElementById('quadrant-chart-rect-container');
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#quadrant-chart-rect")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const centerX = width / 2;
            const centerY = height / 2;

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6", quadrant: 'top-left' },
                { name: "Red", value: scores.red, color: "#EF4444", quadrant: 'top-right' },
                { name: "Green", value: scores.green, color: "#22C55E", quadrant: 'bottom-left' },
                { name: "Yellow", value: scores.yellow, color: "#FACC15", quadrant: 'bottom-right' }
            ];

            const maxPossibleScore = 240;
            const maxPossibleSide = Math.sqrt(maxPossibleScore);
            const maxRadius = Math.min(width / 2, height / 2) * 0.95; 
            const scale = maxRadius / maxPossibleSide; 

            const averageScore = 120;
            const averageSide = Math.sqrt(averageScore);
            const averageScaledSide = averageSide * scale; // This is the 'radius' for the rect

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            // --- Draw the squares FIRST ---
            data.forEach(d => {
                d.side = Math.sqrt(d.value);
                const scaledSide = d.side * scale; 

                let x, y, textX, textY;
                switch (d.quadrant) {
                    case 'top-left': x = -scaledSide; y = -scaledSide; textX = -scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'top-right': x = 0; y = -scaledSide; textX = scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'bottom-left': x = -scaledSide; y = 0; textX = -scaledSide / 2; textY = scaledSide / 2; break;
                    case 'bottom-right': x = 0; y = 0; textX = scaledSide / 2; textY = scaledSide / 2; break;
                }

                chartGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", scaledSide)
                    .attr("height", scaledSide)
                    .attr("fill", d.color);

                if (scaledSide > 60) {
                    chartGroup.append("text")
                        .attr("class", "chart-label-title")
                        .attr("x", textX)
                        .attr("y", textY - 10)
                        .text(d.name);
                    chartGroup.append("text")
                        .attr("class", "chart-label-score") // <-- FIX 3 HERE
                        .attr("x", textX)
                        .attr("y", textY + 16)
                        .text(d.value);
                }
            });

            // --- Draw the axes to divide colors ---
            const axisColor = "#4b5563"; // gray-600
            const axisWidth = 2;
            
            // Y-axis (vertical)
            chartGroup.append("line")
                .attr("x1", 0)
                .attr("y1", -maxRadius)
                .attr("x2", 0)
                .attr("y2", maxRadius)
                .attr("stroke", axisColor)
                .attr("stroke-width", axisWidth);

            // X-axis (horizontal)
            chartGroup.append("line")
                .attr("x1", -maxRadius)
                .attr("y1", 0)
                .attr("x2", maxRadius)
                .attr("y2", 0)
                .attr("stroke", axisColor)
                .attr("stroke-width", axisWidth);
            // --- END AXES ---

            // --- Draw the average RECTANGLE LAST (so it's on top) ---
            chartGroup.append("rect")
                .attr("x", -averageScaledSide)
                .attr("y", -averageScaledSide)
                .attr("width", averageScaledSide * 2)
                .attr("height", averageScaledSide * 2)
                .attr("fill", "none")
                .attr("stroke", "#6b7280") // gray-500
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4 4"); // Make it dashed
        }
        // --- END FUNCTION ---


        // --- CHART 2: AREA (TRIANGLE) CHART ---
        function drawRadarChart(scores) {
            // This function is no longer called
        }
        
        // --- CHART 3: DONUT CHART ---
        function drawDonutChart(scores) {
            const container = document.getElementById('donut-chart-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2 * 0.9;
            const innerRadius = radius * 0.6;

            const svg = d3.select("#donut-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6" },
                { name: "Red", value: scores.red, color: "#EF4444" },
                { name: "Green", value: scores.green, color: "#22C55E" },
                { name: "Yellow", value: scores.yellow, color: "#FACC15" } // <-- CHANGED COLOR
            ].filter(d => d.value > 0);

            if (data.length === 0) return;

            const total = d3.sum(data, d => d.value);

            const pie = d3.pie().value(d => d.value).sort(null);
            const arc = d3.arc().innerRadius(innerRadius).outerRadius(radius);

            const arcs = chartGroup.selectAll(".arc")
                .data(pie(data))
                .enter().append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("stroke", "white")
                .style("stroke-width", "2px");

            arcs.append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("dy", "0.35em")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .style("font-size", "1.1rem")
                .style("font-weight", "600")
                .style("text-shadow", "0 0 3px rgba(0,0,0,0.7)")
                .text(d => {
                    if (total === 0) return "0%";
                    const percent = (d.data.value / total) * 100;
                    return `${percent.toFixed(0)}%`;
                });
        }

        // --- CHART 4: PIE CHART ---
        function drawPieChart(scores) {
            const container = document.getElementById('pie-chart-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2 * 0.9;
            const innerRadius = 0; // The only difference from Donut Chart

            const svg = d3.select("#pie-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6" },
                { name: "Red", value: scores.red, color: "#EF4444" },
                { name: "Green", value: scores.green, color: "#22C55E" },
                { name: "Yellow", value: scores.yellow, color: "#FACC15" }
            ].filter(d => d.value > 0);

            if (data.length === 0) return; 

            const total = d3.sum(data, d => d.value);

            const pie = d3.pie().value(d => d.value).sort(null);
            const arc = d3.arc().innerRadius(innerRadius).outerRadius(radius);

            const arcs = chartGroup.selectAll(".arc")
                .data(pie(data))
                .enter().append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("stroke", "white")
                .style("stroke-width", "2px");

            arcs.append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("dy", "0.35em")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .style("font-size", "1.1rem")
                .style("font-weight", "600")
                .style("text-shadow", "0 0 3px rgba(0,0,0,0.7)")
                .text(d => {
                    if (total === 0) return "0%";
                    const percent = (d.data.value / total) * 100;
                    return `${percent.toFixed(0)}%`;
                });
        }

        // --- DRAG AND DROP HANDLERS ---
        
        function handleDragStart(e) {
            const target = e.target.closest('.draggable-word');
            if (!target) return;
            
            draggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.textContent); // Necessary for Firefox
            setTimeout(() => target.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            // This is a cleanup function for drops that *don't* land in a valid dropzone
            // (e.g., dropped outside the window)
            // --- FIX V3: Check if item is still being tracked ---
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
            }
            draggedItem = null; // Always clear on dragend
            // --- END FIX V3 ---
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        }

        function handleDragOver(e) {
            e.preventDefault();
            const dropzone = e.target.closest('.drop-spot, .word-bank-dropzone');
            if (dropzone) {
                // Prevent dropping a word in a full spot *that isn't the one it came from*
                if (dropzone.classList.contains('drop-spot') && dropzone.children.length > 1 && draggedItem && draggedItem.parentElement !== dropzone) {
                    // This is a full spot, don't highlight
                } else {
                    dropzone.classList.add('highlight');
                }
            }
        }

        function handleDragLeave(e) {
            const dropzone = e.target.closest('.drop-spot, .word-bank-dropzone');
            if (dropzone) {
                dropzone.classList.remove('highlight');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            
            // --- FIX V4: Use a local variable and clear global immediately ---
            if (!draggedItem) return; // A drop event somehow fired without a dragged item
            const itemToDrop = draggedItem; // "Claim" the item
            draggedItem = null; // Clear global immediately
            itemToDrop.classList.remove('dragging'); // Stop the dragging style
            // --- END FIX V4 ---

            const dropzone = e.target.closest('.drop-spot, .word-bank-dropzone');
            if (!dropzone) return; // Didn't land in a valid spot

            dropzone.classList.remove('highlight');
            const card = dropzone.closest('.question-card');
            
            // Case 1: Dropping in a Rank Spot
            if (dropzone.classList.contains('drop-spot')) {
                // If spot is already full, move existing word back to bank
                if (dropzone.children.length > 1) { // 2 children = labels + word
                    const existingWord = dropzone.querySelector('.draggable-word');
                    if (existingWord && existingWord !== itemToDrop) { // Don't move item if dropping on self
                        card.querySelector('.word-bank-dropzone').appendChild(existingWord);
                    }
                }
                dropzone.appendChild(itemToDrop); // Use local copy
                dropzone.classList.add('drop-spot-filled');
            }
            
            // Case 2: Dropping back in the Word Bank
            if (dropzone.classList.contains('word-bank-dropzone')) {
                const originalSpot = itemToDrop.closest('.drop-spot'); // Use local copy
                if (originalSpot) {
                    originalSpot.classList.remove('drop-spot-filled');
                }
                dropzone.appendChild(itemToDrop); // Use local copy
            }
            
            // Validate the card that was just changed
            if (card) {
                validateCard(card);
                checkFormCompletion(false); // Check current card for 'next'
            }
        }


        // --- INITIALIZATION & EVENT LISTENERS ---

        function initialize() {
            // Render all questions
            questionsData.forEach((words, index) => {
                const card = createQuestionCard(words, index);
                questionsContainer.appendChild(card);
            });
            
            showQuestion(currentQuestionIndex);

            // --- Global Drag and Drop Listeners ---
            document.addEventListener('dragstart', handleDragStart);
            document.addEventListener('dragend', handleDragEnd);
            document.addEventListener('dragover', handleDragOver);
            document.addEventListener('dragleave', handleDragLeave);
            document.addEventListener('drop', handleDrop);

            // --- Button Listeners ---
            saveButton.addEventListener('click', () => {
                checkFormCompletion(true); // Final check
                if (!saveButton.disabled) {
                    
                    // NEW: Collect both scores and words
                    const { scores, rankedWords } = collectRankedWords();
                    
                    testPage.classList.add('hidden');
                    resultsPage.classList.remove('hidden');

                    setTimeout(() => {
                        // NEW: Populate the Key Words section
                        populateWordAnalysis(scores, rankedWords); // <-- Pass scores in
                        
                        // Call all other charts
                        drawQuadrantChart(scores);
                        drawQuadrantChartNoAxis(scores); 
                        drawQuadrantChartRectangle(scores); 
                        drawDonutChart(scores);
                        drawPieChart(scores); 
                    }, 10); 

                    successMessage.textContent = 'Answers saved and results calculated!';
                    setTimeout(() => { successMessage.textContent = ''; }, 3000);
                }
            });

            backToTestButton.addEventListener('click', () => {
                resultsPage.classList.add('hidden');
                testPage.classList.remove('hidden');
            });
            
            nextButton.addEventListener('click', () => {
                if (currentQuestionIndex < totalQuestions - 1) {
                    currentQuestionIndex++;
                    showQuestion(currentQuestionIndex);
                }
            });

            prevButton.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    showQuestion(currentQuestionIndex);
                }
            });

            devFillButton.addEventListener('click', () => {
                const allCards = document.querySelectorAll('.question-card');
                allCards.forEach(card => {
                    const wordBank = card.querySelector('.word-bank-dropzone');
                    const spots = card.querySelectorAll('.drop-spot');
                    const words = Array.from(wordBank.querySelectorAll('.draggable-word'));
                    
                    // Shuffle words
                    for (let i = words.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [words[i], words[j]] = [words[j], words[i]];
                    }
                    
                    // Place words in spots
                    words.forEach((word, index) => {
                        if (spots[index]) {
                            spots[index].appendChild(word);
                            spots[index].classList.add('drop-spot-filled');
                        }
                    });
                    validateCard(card);
                });

                successMessage.textContent = 'All answers randomly filled!';
                setTimeout(() => { successMessage.textContent = ''; }, 3000);
                
                currentQuestionIndex = totalQuestions - 1;
                showQuestion(currentQuestionIndex);
            });
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>




